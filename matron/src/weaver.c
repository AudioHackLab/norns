
/*
  weaver.c

  some functions herein are copied from the lua source code:
  ** $Id: lua.h,v 1.331 2016/05/30 15:53:28 roberto Exp roberto $
  ** Lua - A Scripting Language
  ** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
  ** See Copyright Notice at the end of this file

  */


#include <pthread.h>

#include <signal.h>
#include <stdio.h>
#include <string.h>

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#include "events.h"
#include "m.h"
#include "timers.h"
#include "oracle.h"
#include "weaver.h"

//------
//---- global lua state!
lua_State* lvm;

//-----------------------
//--- following functions are lifted from lua.c

int lua_msg_handler(lua_State* l) {
  const char *msg = lua_tostring(l, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(l, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(l, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(l, "(error object is a %s value)",
							luaL_typename(l, 1));
  }
  luaL_traceback(l, l, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */ 
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(NULL, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

/*
** Hook set by signal function to stop the interpreter.
*/
static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);  /* reset hook */
  luaL_error(L, "interrupted!");
}

/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
  lua_sethook(lvm, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, lua_msg_handler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  //  lvm = L;  /* to be available to 'laction' */
  signal(SIGINT, laction);  /* set C-signal handler */
  status = lua_pcall(L, narg, nres, base);
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}


static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}

static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}

static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}

//---------------
//---- external function definitions

/* void handle_lua_error(int val) { */
/*   switch(val) { */
/*   case LUA_ERRRUN: */
/* 	printf("[lua runtime error!] \n"); */
/* 	break; */
/*   case LUA_ERRMEM: */
/* 	printf("[lua memory allocation error!]\n"); */
/* 	break; */
/*   case LUA_ERRGCMM: */
/* 	printf("[lua __gc metamethod error!]\n"); */
/* 	break; */
/*   case LUA_OK: */
/*   default: */
/* 	;; // nothing to do */
/*   } */

/* } */

void w_run_code(const char* code) {
  //  luaL_loadstring(lvm, code); // compile code, push to stack
  //  int ret = lua_pcall(lvm, 0, LUA_MULTRET, 0); // pop stack and evaluate
  //  if(ret) { handle_lua_error(ret); }
  dostring(lvm, code, "w_run_code");
  fflush(stdout);
}							

//-------------
//--- declare lua->c glue
static int w_grid_set_led(lua_State* l);
static int w_request_engine_report(lua_State* l);
static int w_load_engine(lua_State* l);

// FIXME: should support dynamically defined OSC format 'engine methods'
// (one fn to request method list, one for varargs OSC)
// for now, hardcode methods for "buffers" and "parameters"
static int w_request_buffer_report(lua_State* l);
static int w_load_buffer_name(lua_State* l);
static int w_request_param_report(lua_State* l);
static int w_set_param_name(lua_State* l);

// manage timers from lua
static int w_timer_add(lua_State* l);
static int w_timer_stop(lua_State* l);


// screen functions
// TODO
// static void w_screen_print(void);
// static extern void w_screen_draw();

void w_init(void) {
  printf("starting lua vm \n");
  lvm = luaL_newstate();
  luaL_openlibs(lvm);
  lua_pcall(lvm, 0, 0, 0);
  fflush(stdout);

  // register c functions
  // FIXME: pull these from some kind of descriptor stucture instead
  // not sure how to correctly document lua
  lua_register(lvm, "grid_set_led", &w_grid_set_led);
  
  lua_register(lvm, "report_engines", &w_request_engine_report);
  lua_register(lvm, "load_engine", &w_load_engine);
  
  lua_register(lvm, "report_buffers", &w_request_buffer_report);
  lua_register(lvm, "load_buffer", &w_load_buffer_name);
  // TODO  lua_register(lvm, "load_buffer_idx", &w_load_buffer_index);
  
  lua_register(lvm, "report_params", &w_request_param_report);
  lua_register(lvm, "set_param", &w_set_param_name);
  // TODO  lua_register(lvm, "load_param_idx", &w_load_param_index);

  lua_register(lvm, "start_timer", &w_timer_add);
  lua_register(lvm, "stop_timer", &w_timer_stop);
  
  // run system init code
  w_run_code("dofile(\"lua/norns.lua\");");
}

// run user startup code
// audio backend should be running
void w_user_startup(void) {
  lua_getglobal(lvm, "startup");
  //  lua_pcall(lvm, 0, 0, 0);
  report(lvm, docall(lvm, 0, 0));
}

//----------------------------------
//---- static definitions

int w_grid_set_led(lua_State* l) {
  int res = 0;
  int x, y, z;
  if(lua_gettop(l) != 3) { // check num args
	goto args_error;
  } 
	
  if(lua_isnumber(l, 1)) {
	x = lua_tonumber(l, 1);
  } else {
	goto args_error;
  }
	
  if(lua_isnumber(l, 2)) {
	y = lua_tonumber(l, 2);
  } else {
	goto args_error;
  }
  if(lua_isnumber(l, 3)) {
	z = lua_tonumber(l, 3);
  } else {
	goto args_error;
  }
  
  m_grid_set_led(x, y, z);
  return 0;
  
 args_error:
  printf("warning: incorrect arguments to grid_set_led() \n"); fflush(stdout);
  return 1;
}

//-- audio processing controls
int w_load_engine(lua_State* l) {
  if(lua_gettop(l) != 1) {
	goto args_error;
  }
  
  if(lua_isstring(l, 1)) {
	o_load_engine(lua_tostring(l, 1));
	return 0;
  } else {
	goto args_error;
  }
  
 args_error:
  printf("warning: incorrect arguments to load_engine() \n"); fflush(stdout);
  return 1;
}

// FIXME: should support dynamically defined OSC formats
int w_load_buffer_name(lua_State* l) {
  if(lua_gettop(l) != 2) {
	goto args_error;
  }
  if(lua_isstring(l, 1) && lua_isstring(l, 2)) {
	o_load_buffer_name(lua_tostring(l, 1), lua_tostring(l, 2));
  } else {
	goto args_error;
  }
  return 0;

 args_error:
  printf("warning: incorrect arguments to load_engine() \n"); fflush(stdout);
  return 1;
}

int w_set_param_name(lua_State* l) {
  if(lua_gettop(l) != 2) {
	goto args_error;
  }
  
  if(lua_isstring(l, 1) && lua_isnumber(l, 2)) {
	o_set_param_name(lua_tostring(l, 1), lua_tonumber(l, 2));
  } else {
	goto args_error;
  }
  return 0;
  
 args_error:
  printf("warning: incorrect arguments to set_param() \n"); fflush(stdout);
  return 1;
}

int w_request_engine_report(lua_State* l) {
  o_request_engine_report();
}

int w_request_buffer_report(lua_State* l) {
  o_request_buffer_report();
}

int w_request_param_report(lua_State* l) {
  o_request_param_report();
}

// manage timers from lua
int w_timer_add(lua_State* l) {
  int idx;
  double seconds;
  int count;
  if(lua_gettop(l) != 3) {
	goto args_error;
  }
  if(lua_isnumber(l, 1)) {
	idx = lua_tonumber(l, 1) - 1; // lua indices are 1-basead
  } else {
	goto args_error;
  }
  if(lua_isnumber(l, 2)) {
	seconds = lua_tonumber(l, 2);
  } else {
	goto args_error;
  }
  if(lua_isnumber(l, 3)) {
	count = lua_tonumber(l, 3);
  } else {
	goto args_error;
  }
  
  timer_add(idx, seconds, count);
  return 0;
  
 args_error:
  printf("warning: incorrect arguments to start_timer() \n"); fflush(stdout);
  return 1;
}

int w_timer_stop(lua_State* l) {
  int idx;
  if(lua_gettop(l) != 1) {
	goto args_error;
  }
  if(lua_isnumber(l, 1)) {
	idx = lua_tonumber(l, 1) - 1;
  } else {
	goto args_error;
  }
  timer_stop(idx);
  return 0;
 args_error:
  printf("warning: incorrect arguments to stop_timer() \n"); fflush(stdout);
  return 1;
}


//---- c -> lua glue

//--- hardware input

/*
  general form:

  void handle_foo(a, b, ... ) { 
  lua_getglobal(l, "handle"); // push table of callbacks to the stack 
  lua_getfield(l, "handle"); // push callback function to stack
  lua_remove(l, -2); // remove the table
  lua_pushinteger(l, a); // push arguments
  lua_pushinteger(l, b); // 
  // ... keep pushing arguments
  lua_call(l, N, 0); // pop stack and call the function with N arguments
*/

/* TODO:
   implement with varargs:
   #include <stdio.h>
   #include <stdarg.h>

   void call_module_function(char* module, char* name, char *fmt, ...)
   {
   va_list ap;
   int d;
   char c, *s;
   double f;

   //... put fn on stack as above ...

   va_start(ap, fmt);
   while (*fmt)
   switch (*fmt++) {
   case 's':
   s = va_arg(ap, char *);
   // ... push string to stack.. 
   break;
   case 'd':
   d = va_arg(ap, int);
   // ... push int to stack.. 
   // push int
   break;
   case 'f':
   f = va_arg(ap, double);
   // ... push double to stack ... 
   break;
   }
   // .. increment arg counter ... 
   va_end(ap);
   }
   /// ... call with count of args ... 
   */

// helper for calling grid handlers
static inline void
w_call_grid_handler(const char* name, int x, int y) {
  lua_getglobal(lvm, "grid");  
  lua_getfield(lvm, -1, name); 
  lua_remove(lvm, -2); 
  lua_pushinteger(lvm, x); 
  lua_pushinteger(lvm, y);
  /* int ret = lua_pcall(lvm, 2, 0, 0); */
  /* if(ret) { handle_lua_error(ret); } */
  report(lvm, docall(lvm, 2, 0));

}
void w_handle_grid_press(int x, int y) {
  w_call_grid_handler("press", x, y);
}

void w_handle_grid_lift(int x, int y) {
  w_call_grid_handler("lift", x, y);
}

// helper for calling joystick handlers
static inline void
w_call_stick_handler(const char* name, int stick, int what, int val) {
  lua_getglobal(lvm, "joystick");  
  lua_getfield(lvm, -1, name); 
  lua_remove(lvm, -2); 
  lua_pushinteger(lvm, stick); 
  lua_pushinteger(lvm, what);
  lua_pushinteger(lvm, val);
  /* int ret = lua_pcall(lvm, 3, 0, 0); */
  /* if(ret) { handle_lua_error(ret); } */
  report(lvm, docall(lvm, 3, 0));
}

void w_handle_stick_axis(int stick, int axis, int value) {
  w_call_stick_handler("axis", stick+1, axis+1, value);
}

void w_handle_stick_button(int stick, int button, int value) {
  w_call_stick_handler("button", stick+1, button+1, value);
}
void w_handle_stick_hat(int stick, int hat, int value) {
  w_call_stick_handler("hat", stick+1, hat+1, value);
}
void w_handle_stick_ball(int stick, int ball, int xrel, int yrel) {
  lua_getglobal(lvm, "joystick");  
  lua_getfield(lvm, -1, "hat"); 
  lua_remove(lvm, -2); 
  lua_pushinteger(lvm, stick); 
  lua_pushinteger(lvm, ball);
  lua_pushinteger(lvm, xrel);
  lua_pushinteger(lvm, yrel);
  /* int ret = lua_pcall(lvm, 4, 0, 0); */
  /* if(ret) { handle_lua_error(ret); } */
  report(lvm, docall(lvm, 4, 0));
}


// helper for pushing array of c strings
static inline void
w_push_string_array(const char** arr, const int n) {
  // allocate and push the table
  lua_createtable(lvm, n, 0);
  // set each entry
  for (int i=0; i<n; i++) {
	lua_pushstring(lvm, arr[i]);
	lua_rawseti(lvm, -2, i+1);
  }
  // push count of entries
  lua_pushinteger(lvm, n);
}

// helper for calling report handlers
static inline void
w_call_report_handler(const char* name, const char** arr, const int num) {
  lua_getglobal(lvm, "report");  
  lua_getfield(lvm, -1, name); 
  lua_remove(lvm, -2); 
  w_push_string_array(arr, num);
  /* int ret = lua_pcall(lvm, 2, 0, 0); */
  /* if(ret) { handle_lua_error(ret); } */
  report(lvm, docall(lvm, 2, 0));
}

// audio engine report handlers
void w_handle_buffer_report(const char** arr, const int num) {
  w_call_report_handler( "buffer", arr, num);
}

void w_handle_engine_report(const char** arr, const int num) {
  w_call_report_handler("engine", arr, num);
}

void w_handle_param_report(const char** arr, const int num) {
  w_call_report_handler("param", arr, num);
}

// timer handler
void w_handle_timer(const int idx, const int count) {
  lua_getglobal(lvm, "timer");
  lua_pushinteger(lvm, idx+1);
  lua_pushinteger(lvm, count);
  /* int ret = lua_pcall(lvm, 2, 0, 0); */
  /* if(ret) { handle_lua_error(ret); } */
  report(lvm, docall(lvm, 2, 0));
}


/******************************************************************************
 * Copyright (C) 1994-2017 Lua.org, PUC-Rio.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
