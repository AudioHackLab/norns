/*
  weaver.c

  some functions herein are copied from the lua source code:
  ** $Id: lua.h,v 1.331 2016/05/30 15:53:28 roberto Exp roberto $
  ** Lua - A Scripting Language
  ** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
  ** See Copyright Notice at the end of this file

  */


#include <pthread.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#include "events.h"
#include "m.h"
#include "timers.h"
#include "oracle.h"
#include "weaver.h"

//------
//---- global lua state!
lua_State* lvm;

//-----------------------
//--- following functions are lifted from lua.c
// FIXME: put these in their own file, methinks

int lua_msg_handler(lua_State* l) {
  const char *msg = lua_tostring(l, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(l, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(l, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(l, "(error object is a %s value)",
							luaL_typename(l, 1));
  }
  luaL_traceback(l, l, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */ 
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(NULL, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

/*
** Hook set by signal function to stop the interpreter.
*/
static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);  /* reset hook */
  luaL_error(L, "interrupted!");
}

/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
  lua_sethook(lvm, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, lua_msg_handler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  //  lvm = L;  /* to be available to 'laction' */
  signal(SIGINT, laction);  /* set C-signal handler */
  status = lua_pcall(L, narg, nres, base);
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}


static int dochunk (lua_State *L, int status) {
  if (status == LUA_OK) status = docall(L, 0, 0);
  return report(L, status);
}

static int dofile (lua_State *L, const char *name) {
  return dochunk(L, luaL_loadfile(L, name));
}

static int dostring (lua_State *L, const char *s, const char *name) {
  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));
}

//-----------------
//---- here resumes non-lifted code.

void w_run_code(const char* code) {
  dostring(lvm, code, "w_run_code");
  fflush(stdout);
}							

//-------------
//--- declare lua->c glue

// grid
static int w_grid_set_led(lua_State* l);

// audio engine
static int w_request_engine_report(lua_State* l);
static int w_load_engine(lua_State* l);

static int w_request_command_report(lua_State* l);
static int w_send_command(lua_State* l);

// manage timers from lua
static int w_timer_start(lua_State* l);
static int w_timer_stop(lua_State* l);


// screen functions
// TODO
// static void w_screen_print(void);
// static extern void w_screen_draw();
//... ?

void w_init(void) {
  printf("starting lua vm \n");
  lvm = luaL_newstate();
  luaL_openlibs(lvm);
  lua_pcall(lvm, 0, 0, 0);
  fflush(stdout);

  // FIXME: how/where to document these in lua
  lua_register(lvm, "grid_set_led", &w_grid_set_led);
  
  lua_register(lvm, "report_engines", &w_request_engine_report);
  lua_register(lvm, "load_engine", &w_load_engine);
  
  lua_register(lvm, "report_commands", &w_request_command_report);
  lua_register(lvm, "send_command", &w_send_command);

  lua_register(lvm, "start_timer", &w_timer_start);
  lua_register(lvm, "stop_timer", &w_timer_stop);
  
  // run system init code
  w_run_code("dofile(\"lua/norns.lua\");");
}

// run user startup code
// audio backend should be running
void w_user_startup(void) {
  lua_getglobal(lvm, "startup");
  report(lvm, docall(lvm, 0, 0));
}

//----------------------------------
//---- static definitions

int w_grid_set_led(lua_State* l) {
  int res = 0;
  int x, y, z;
  if(lua_gettop(l) != 3) { // check num args
	goto args_error;
  } 
	
  if(lua_isnumber(l, 1)) {
	x = lua_tonumber(l, 1);
  } else {
	goto args_error;
  }
	
  if(lua_isnumber(l, 2)) {
	y = lua_tonumber(l, 2);
  } else {
	goto args_error;
  }
  if(lua_isnumber(l, 3)) {
	z = lua_tonumber(l, 3);
  } else {
	goto args_error;
  }
  
  m_grid_set_led(x, y, z);
  return 0;
  
 args_error:
  printf("warning: incorrect arguments to grid_set_led() \n"); fflush(stdout);
  return 1;
}

//-- audio processing controls
int w_load_engine(lua_State* l) {
  if(lua_gettop(l) != 1) {
	goto args_error;
  }
  
  if(lua_isstring(l, 1)) {
	o_load_engine(lua_tostring(l, 1));
	return 0;
  } else {
	goto args_error;
  }
  
 args_error:
  printf("warning: incorrect arguments to load_engine() \n"); fflush(stdout);
  return 1;
}

int w_send_command(lua_State* l) {
  int nargs = lua_gettop(l);
  if(nargs < 1) { goto args_error; }

  char* cmd = NULL;
  char* fmt = NULL;

  if(lua_isnumber(l, 1)) {
	// FIXME? guess should be wrapped in descriptor access lock
	int idx = (int)lua_tonumber(l, 1) - 1; // 1-base to 0-base
	cmd = o_get_commands()[idx].cmd;
	fmt = o_get_commands()[idx].fmt;
  } else {
	printf("failed type check on first arg \n");
	goto args_error; }

  lo_message msg = lo_message_new();

  // debug
  const char* s;
  int d;
  double f;
  
  for(int i=2; i<=nargs; i++) {
	switch(fmt[i-2]) {
	case 's':
	  if(lua_isstring(l, i)) {
		s = lua_tostring(l, i);
		lo_message_add_string(msg, s );
	  } else {
		printf("failed string type check \n");
		goto args_error; }
	  break;
	case 'i':
	  if(lua_isnumber(l, i)) {
		d =  (int)lua_tonumber(l, i) ;
		lo_message_add_int32( msg, d);
	  } else { 
		printf("failed int type check \n");
		goto args_error; }
	  break;
	case 'f':
	  if(lua_isnumber(l, i)) {
		f = lua_tonumber(l, i);
		lo_message_add_double( msg, f );
	  } else { 
		printf("failed double type check \n");
		goto args_error; }
	  break;
	default:
	  break;
	}
  }

  if(cmd == NULL || fmt == NULL) {
	printf("error: null format/command string \n");
	return 1;
  } else {
	o_send_command(cmd, msg);
  }
  return 0;
  
 args_error:
  printf("warning: incorrect arguments to send_command() \n"); fflush(stdout);
  return 1;
}
  
int w_request_engine_report(lua_State* l) {
  o_request_engine_report();
}

int w_request_command_report(lua_State* l) {
  o_request_command_report();
}

// manage timers from lua
int w_timer_start(lua_State* l) {
  int idx;
  double seconds;
  int count;
  if(lua_gettop(l) != 3) {
	goto args_error;
  }
  if(lua_isnumber(l, 1)) {
	idx = lua_tonumber(l, 1) - 1; // 1-base to 0-base
  } else {
	goto args_error;
  }
  if(lua_isnumber(l, 2)) {
	seconds = lua_tonumber(l, 2);
  } else {
	goto args_error;
  }
  if(lua_isnumber(l, 3)) {
	count = lua_tonumber(l, 3);
  } else {
	goto args_error;
  }
  
  timer_start(idx, seconds, count);
  return 0;
  
 args_error:
  printf("warning: incorrect arguments to start_timer() \n"); fflush(stdout);
  return 1;
}

int w_timer_stop(lua_State* l) {
  int idx;
  if(lua_gettop(l) != 1) {
	goto args_error;
  }
  if(lua_isnumber(l, 1)) {
	idx = lua_tonumber(l, 1) - 1;
  } else {
	goto args_error;
  }
  timer_stop(idx);
  return 0;
 args_error:
  printf("warning: incorrect arguments to stop_timer() \n"); fflush(stdout);
  return 1;
}


//---- c -> lua glue

//--- hardware input

// helper for calling grid handlers
static inline void
w_call_grid_handler(const char* name, int x, int y) {
  lua_getglobal(lvm, "grid");  
  lua_getfield(lvm, -1, name); 
  lua_remove(lvm, -2); 
  lua_pushinteger(lvm, x); 
  lua_pushinteger(lvm, y);
  report(lvm, docall(lvm, 2, 0));

}
void w_handle_grid_press(int x, int y) {
  printf("passing grid press to LVM: (%d, %d)\n", x, y); 
  w_call_grid_handler("press", x, y);
}

void w_handle_grid_lift(int x, int y) {
  printf("passing grid lift to LVM: (%d, %d)\n", x, y);
  w_call_grid_handler("lift", x, y);
}

// helper for calling joystick handlers
static inline void
w_call_stick_handler(const char* name, int stick, int what, int val) {
  lua_getglobal(lvm, "joystick");  
  lua_getfield(lvm, -1, name); 
  lua_remove(lvm, -2); 
  lua_pushinteger(lvm, stick); 
  lua_pushinteger(lvm, what);
  lua_pushinteger(lvm, val);
  report(lvm, docall(lvm, 3, 0));
}

void w_handle_stick_axis(int stick, int axis, int value) {
  w_call_stick_handler("axis", stick+1, axis+1, value);
}

void w_handle_stick_button(int stick, int button, int value) {
  w_call_stick_handler("button", stick+1, button+1, value);
}
void w_handle_stick_hat(int stick, int hat, int value) {
  w_call_stick_handler("hat", stick+1, hat+1, value);
}
void w_handle_stick_ball(int stick, int ball, int xrel, int yrel) {
  lua_getglobal(lvm, "joystick");  
  lua_getfield(lvm, -1, "hat"); 
  lua_remove(lvm, -2); 
  lua_pushinteger(lvm, stick); 
  lua_pushinteger(lvm, ball);
  lua_pushinteger(lvm, xrel);
  lua_pushinteger(lvm, yrel);
  report(lvm, docall(lvm, 4, 0));
}

// helper for pushing array of c strings
static inline void
w_push_string_array(const char** arr, const int n) {
  // push a table of strings
  lua_createtable(lvm, n, 0);
  for (int i=0; i<n; i++) {
	lua_pushstring(lvm, arr[i]);
	lua_rawseti(lvm, -2, i+1);
  }
  // push count of entries
  lua_pushinteger(lvm, n);
}


// audio engine report handlers
void w_handle_engine_report(const char** arr, const int n) {
  lua_getglobal(lvm, "report");  
  lua_getfield(lvm, -1, "engines"); 
  lua_remove(lvm, -2);
  w_push_string_array(arr, n);
  report(lvm, docall(lvm, 2, 0));
}

void w_handle_command_report(const struct engine_command* arr,
							 const int num) {
  lua_getglobal(lvm, "report");
  lua_getfield(lvm, -1, "commands");
  lua_remove(lvm, -2);
  // push a table of tables: {{cmd, fmt}, {cmd,fmt}, ...}
  lua_createtable(lvm, num, 0);
  for(int i=0; i<num; i++) {
	lua_createtable(lvm, 2, 0);
	lua_pushstring(lvm, arr[i].cmd);
	lua_rawseti(lvm, -2, 1);
	lua_pushstring(lvm, arr[i].fmt);
	lua_rawseti(lvm, -2, 2);
	lua_rawseti(lvm, -2, i+1);
  }
  lua_pushinteger(lvm, num);
  report(lvm, docall(lvm, 2, 0));
}

// timer handler
void w_handle_timer(const int idx, const int count) {
  lua_getglobal(lvm, "timer");
  lua_pushinteger(lvm, idx+1);
  lua_pushinteger(lvm, count);
  report(lvm, docall(lvm, 2, 0));
}

/******************************************************************************
 * Copyright (C) 1994-2017 Lua.org, PUC-Rio.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
